<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox Data Sender</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 600px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #333;
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .header p {
            color: #666;
            font-size: 1.1em;
        }
        .tab-container {
            display: flex;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 5px;
        }
        .tab-button {
            flex: 1;
            padding: 15px;
            background: transparent;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            color: #666;
        }
        .tab-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .form-group {
            margin-bottom: 25px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
            font-size: 1.1em;
        }
        .form-control {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
        }
        .form-control:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .form-control::placeholder {
            color: #999;
        }
        textarea.form-control {
            resize: vertical;
            min-height: 120px;
            font-family: 'Courier New', monospace;
        }
        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .btn.secondary {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            margin-top: 10px;
        }
        .btn.secondary:hover {
            box-shadow: 0 10px 20px rgba(107, 114, 128, 0.3);
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .status-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 350px;
        }
        .status {
            padding: 15px 20px;
            border-radius: 10px;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }
        .status.show {
            opacity: 1;
            transform: translateX(0);
        }
        .status.success {
            background: rgba(34, 197, 94, 0.95);
            color: white;
            border-left: 4px solid #22c55e;
        }
        .status.error {
            background: rgba(239, 68, 68, 0.95);
            color: white;
            border-left: 4px solid #ef4444;
        }
        .status.info {
            background: rgba(59, 130, 246, 0.95);
            color: white;
            border-left: 4px solid #3b82f6;
        }
        .execution-status {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            display: none;
        }
        .execution-status h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }
        .message-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .message-user {
            font-weight: 600;
            color: #667eea;
        }
        .message-jobid {
            font-weight: 600;
            color: #764ba2;
        }
        .message-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        .status-pending {
            background: #fef3c7;
            color: #92400e;
        }
        .status-success {
            background: #d1fae5;
            color: #065f46;
        }
        .status-failed {
            background: #fee2e2;
            color: #991b1b;
        }
        .message-content {
            background: #1f2937;
            color: #f9fafb;
            padding: 10px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .message-time {
            font-size: 12px;
            color: #6b7280;
            margin-top: 8px;
        }
        .server-status {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            display: none;
        }
        .server-status h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }
        .server-item {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        .server-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .server-jobid {
            font-weight: 600;
            color: #0369a1;
        }
        .server-players {
            color: #666;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .status-container {
                position: static;
                max-width: none;
                margin-top: 20px;
            }
            .status {
                transform: none;
                opacity: 1;
            }
            .status.show {
                transform: none;
            }
            .container {
                max-width: 100%;
                padding: 20px;
            }
            .tab-button {
                padding: 10px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Roblox Data Sender</h1>
            <p>Send data to your Roblox server endpoint</p>
        </div>
        
        <div class="tab-container">
            <button class="tab-button active" onclick="switchTab('username')">üë§ Username</button>
            <button class="tab-button" onclick="switchTab('jobid')">üñ•Ô∏è Job ID</button>
            <button class="tab-button" onclick="switchTab('status')">üìä Status</button>
        </div>

        <div id="username-tab" class="tab-content active">
            <form id="usernameForm">
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" class="form-control" 
                           placeholder="Enter target username" required>
                </div>
                <div class="form-group">
                    <label for="usernameData">Data String</label>
                    <textarea id="usernameData" class="form-control" 
                              placeholder="Enter the code/data to send to this user" required></textarea>
                </div>
                <button type="submit" class="btn" id="sendUsernameBtn">
                    Send to Username
                </button>
            </form>
        </div>

        <div id="jobid-tab" class="tab-content">
            <form id="jobidForm">
                <div class="form-group">
                    <label for="jobid">Job ID</label>
                    <input type="text" id="jobid" class="form-control" 
                           placeholder="Enter target Job ID" required>
                </div>
                <div class="form-group">
                    <label for="jobidData">Data String</label>
                    <textarea id="jobidData" class="form-control" 
                              placeholder="Enter the code/data to send to this server" required></textarea>
                </div>
                <button type="submit" class="btn" id="sendJobidBtn">
                    Send to Job ID
                </button>
            </form>
        </div>

        <div id="status-tab" class="tab-content">
            <button class="btn secondary" onclick="refreshStatus()">üîÑ Refresh Status</button>
            <div id="serverStatus" class="server-status"></div>
        </div>

        <div id="executionStatus" class="execution-status"></div>
    </div>

    <div id="statusContainer" class="status-container"></div>

    <script>
        const statusContainer = document.getElementById('statusContainer');
const executionStatusDiv = document.getElementById('executionStatus');
const serverStatusDiv = document.getElementById('serverStatus');
const defaultServerUrl = 'https://am-i-three.vercel.app/api';

let statusIdCounter = 0;
let currentTab = 'username';
let isMonitoring = false; // Add flag to prevent multiple monitoring instances

// Add place info cache to prevent rate limiting
const placeInfoCache = new Map(); // Cache to store place info by ID

function switchTab(tab) {
    // Update tab buttons
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
    document.getElementById(tab + '-tab').classList.add('active');
    
    currentTab = tab;
    
    // Load status if switching to status tab
    if (tab === 'status') {
        refreshStatus();
    }
}

function showStatus(message, type, duration = 6000) {
    const statusId = 'status-' + (++statusIdCounter);
    const statusDiv = document.createElement('div');
    statusDiv.id = statusId;
    statusDiv.className = `status ${type}`;
    statusDiv.innerHTML = message;
    
    statusContainer.appendChild(statusDiv);
    
    // Trigger animation
    setTimeout(() => {
        statusDiv.classList.add('show');
    }, 10);
    
    // Auto remove after duration
    setTimeout(() => {
        statusDiv.classList.remove('show');
        setTimeout(() => {
            if (statusDiv.parentNode) {
                statusDiv.parentNode.removeChild(statusDiv);
            }
        }, 300);
    }, duration);
}

function formatTime(timestamp) {
    return new Date(timestamp).toLocaleTimeString();
}

function getStatusBadge(message, allStatusData) {
    // If message has executedAt, it was executed - check ran field for success/failure
    if (message.executedAt) {
        if (message.ran === true) {
            return '<span class="message-status status-success">‚úÖ Success</span>';
        } else if (message.ran === false) {
            return '<span class="message-status status-failed">‚ùå Failed</span>';
        }
    }
    
    // If message is still in pending messages (users/jobids), it's pending
    return '<span class="message-status status-pending">‚è≥ Pending</span>';
}

// Modified fetchPlaceInfo function with caching
async function fetchPlaceInfo(placeId) {
  // Check if we already have this ID cached
  if (placeInfoCache.has(placeId)) {
    console.log(`Using cached data for place ID: ${placeId}`);
    return placeInfoCache.get(placeId);
  }

  try {
    console.log(`Fetching new data for place ID: ${placeId}`);
    
    // Use a CORS proxy to bypass CORS restrictions
    const proxyUrl = 'https://corsproxy.io/?';
    
    // First get the universe ID from place ID
    const universeResponse = await fetch(`${proxyUrl}https://apis.roblox.com/universes/v1/places/${placeId}/universe`);
    const universeData = await universeResponse.json();
    
    if (!universeData.universeId) {
      throw new Error('No universe ID found');
    }
    
    // Then get game info from universe ID
    const gameResponse = await fetch(`${proxyUrl}https://games.roblox.com/v1/games?universeIds=${universeData.universeId}`);
    const gameData = await gameResponse.json();
    
    let placeInfo = {
      name: 'Unknown Place',
      thumbnailUrl: null
    };
    
    if (gameData.data && gameData.data[0]) {
      const game = gameData.data[0];
      
      // Get high-quality thumbnail using the better endpoint
      const thumbnailResponse = await fetch(`${proxyUrl}https://thumbnails.roblox.com/v1/games/icons?universeIds=${universeData.universeId}&size=512x512&format=Png&isCircular=false`);
      const thumbnailData = await thumbnailResponse.json();
      
      let thumbnailUrl = null;
      if (thumbnailData.data && thumbnailData.data[0] && thumbnailData.data[0].imageUrl) {
        thumbnailUrl = thumbnailData.data[0].imageUrl;
      }
      
      placeInfo = {
        name: game.name,
        description: game.description,
        creator: game.creator,
        playing: game.playing,
        visits: game.visits,
        maxPlayers: game.maxPlayers,
        created: game.created,
        updated: game.updated,
        universeId: universeData.universeId,
        thumbnailUrl: thumbnailUrl
      };
    }
    
    // Cache the result
    placeInfoCache.set(placeId, placeInfo);
    console.log(`Cached data for place ID: ${placeId}`);
    
    return placeInfo;
    
  } catch (error) {
    console.error('Failed to fetch place info:', error);
    
    // Cache the error result to prevent retrying
    const errorResult = {
      name: 'Unknown Place',
      thumbnailUrl: null,
      error: true
    };
    
    placeInfoCache.set(placeId, errorResult);
    return errorResult;
  }
}

// New function to handle batch fetching with rate limiting
async function fetchPlaceInfoBatch(placeIds, serversByPlaceId) {
    const BATCH_DELAY = 1000; // 1 second delay between requests
    
    for (let i = 0; i < placeIds.length; i++) {
        const placeId = placeIds[i];
        
        try {
            // Add delay between requests to prevent rate limiting
            if (i > 0) {
                await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
            }
            
            const placeInfo = await fetchPlaceInfo(placeId);
            
            // Update all servers that use this place ID
            const serversForPlace = serversByPlaceId.get(placeId) || [];
            
            serversForPlace.forEach(({ jobId, serverInfo }) => {
                const placeElement = document.getElementById(`place-${jobId}`);
                if (placeElement) {
                    placeElement.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                            ${placeInfo.thumbnailUrl ? `<img src="${placeInfo.thumbnailUrl}" alt="Place thumbnail" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">` : ''}
                            <div>
                                <div style="font-weight: 500; color: #333;">üéÆ ${placeInfo.name}</div>
                                <div style="font-size: 11px; color: #666;">Place ID: ${placeId}</div>
                            </div>
                        </div>
                    `;
                }
            });
            
        } catch (error) {
            console.error(`Error fetching place info for ID ${placeId}:`, error);
        }
    }
}
        
async function fetchExecutionStatus() {
    try {
        console.log('Fetching execution status...');
        const response = await fetch(defaultServerUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'User-Agent': 'RobloxStudio/1.0',
                'Referer': 'https://www.roblox.com'
            },
            body: JSON.stringify({ action: 'status' }),
            mode: 'cors'
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Full status response:', data);
        
        if (data.success && data.data) {
            return data.data;
        } else {
            console.log('No success or data in response');
            return null;
        }
    } catch (error) {
        console.error('Failed to fetch status:', error);
        return null;
    }
}

function displayExecutionStatus(statusData) {
    console.log('Displaying execution status with data:', statusData);
    
    if (!statusData) {
        executionStatusDiv.innerHTML = '<h3>üìã Execution Status</h3><p>Failed to load status data.</p>';
        executionStatusDiv.style.display = 'block';
        return;
    }
    
    // executedMessages is at the top level of statusData
    const executedMessages = statusData.executedMessages || [];
    
    // users and jobids are inside the message object
    let messageData = statusData.message || {};
    console.log('Message data:', messageData);
    
    const users = messageData.users || {};
    const jobids = messageData.jobids || {};
    
    let html = '<h3>üìã Execution Status</h3>';
    
    const hasExecutedMessages = executedMessages.length > 0;
    const hasUserMessages = Object.keys(users).length > 0;
    const hasJobIdMessages = Object.keys(jobids).length > 0;
    
    console.log('Has executed messages:', hasExecutedMessages, 'Has user messages:', hasUserMessages, 'Has job messages:', hasJobIdMessages);
    
    if (!hasExecutedMessages && !hasUserMessages && !hasJobIdMessages) {
        html += '<p>No messages found.</p>';
    } else {
        // Display executed messages (successful)
        if (hasExecutedMessages) {
            html += '<h4>üì® Executed Messages</h4>';
            
            const groupedMessages = {};
            
            executedMessages.forEach(msg => {
                const key = `${msg.type}-${msg.target}`;
                if (!groupedMessages[key]) {
                    groupedMessages[key] = {
                        type: msg.type,
                        target: msg.target,
                        messages: []
                    };
                }
                groupedMessages[key].messages.push(msg);
            });
            
            for (const [key, group] of Object.entries(groupedMessages)) {
                const icon = group.type === 'username' ? 'üë§' : 'üñ•Ô∏è';
                const label = group.type === 'username' ? 'Username' : 'Job ID';
                
                html += `<div class="message-item">
                    <div class="message-header">
                        <span class="message-${group.type}">${icon} ${label}: ${group.target}</span>
                        <span>${group.messages.length} message(s)</span>
                    </div>`;
                
                group.messages.forEach(msg => {
                    console.log('Processing executed message:', msg);
                    html += `
                        <div style="margin-left: 15px; margin-bottom: 10px; padding: 10px; background: white; border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <small style="color: #666;">ID: ${msg.id || 'Unknown'}</small>
                                ${getStatusBadge(msg)}
                            </div>
                            <div class="message-content">${msg.content || msg.data || 'No content'}</div>
                            <div class="message-time">
                                Sent: ${msg.timestamp ? formatTime(msg.timestamp) : 'Unknown time'}
                                ${msg.executedAt ? `‚Ä¢ Executed: ${formatTime(msg.executedAt)}` : ''}
                            </div>
                        </div>`;
                });
                
                html += '</div>';
            }
        }
        
        // Display pending user messages
        if (hasUserMessages) {
            html += '<h4>üë§ Pending User Messages</h4>';
            for (const [username, messages] of Object.entries(users)) {
                console.log(`Processing user ${username} with messages:`, messages);
                
                if (!Array.isArray(messages)) {
                    console.warn(`Messages for user ${username} is not an array:`, messages);
                    continue;
                }
                
                html += `<div class="message-item">
                    <div class="message-header">
                        <span class="message-user">üë§ ${username}</span>
                        <span>${messages.length} message(s)</span>
                    </div>`;
                
                messages.forEach(msg => {
                    console.log('Processing pending user message:', msg);
                    html += `
                        <div style="margin-left: 15px; margin-bottom: 10px; padding: 10px; background: white; border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <small style="color: #666;">ID: ${msg.id || 'Unknown'}</small>
                                <span class="message-status status-pending">‚è≥ Pending</span>
                            </div>
                            <div class="message-content">${msg.content || msg.data || 'No content'}</div>
                            <div class="message-time">
                                Sent: ${msg.timestamp ? formatTime(msg.timestamp) : 'Unknown time'}
                            </div>
                        </div>`;
                });
                
                html += '</div>';
            }
        }
        
        // Display pending job ID messages
        if (hasJobIdMessages) {
            html += '<h4>üñ•Ô∏è Pending Job ID Messages</h4>';
            for (const [jobId, messages] of Object.entries(jobids)) {
                console.log(`Processing job ID ${jobId} with messages:`, messages);
                
                if (!Array.isArray(messages)) {
                    console.warn(`Messages for job ID ${jobId} is not an array:`, messages);
                    continue;
                }
                
                html += `<div class="message-item">
                    <div class="message-header">
                        <span class="message-jobid">üñ•Ô∏è ${jobId}</span>
                        <span>${messages.length} message(s)</span>
                    </div>`;
                
                messages.forEach(msg => {
                    console.log('Processing pending job message:', msg);
                    html += `
                        <div style="margin-left: 15px; margin-bottom: 10px; padding: 10px; background: white; border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <small style="color: #666;">ID: ${msg.id || 'Unknown'}</small>
                                <span class="message-status status-pending">‚è≥ Pending</span>
                            </div>
                            <div class="message-content">${msg.content || msg.data || 'No content'}</div>
                            <div class="message-time">
                                Sent: ${msg.timestamp ? formatTime(msg.timestamp) : 'Unknown time'}
                            </div>
                        </div>`;
                });
                
                html += '</div>';
            }
        }
    }
    
    executionStatusDiv.innerHTML = html;
    executionStatusDiv.style.display = 'block';
}

// Modified displayServerStatus function with batch processing
function displayServerStatus(statusData) {
    console.log('Displaying server status with data:', statusData);
    
    if (!statusData || !statusData.servers) {
        serverStatusDiv.innerHTML = '<h3>üñ•Ô∏è Server Status</h3><p>No servers currently active.</p>';
        serverStatusDiv.style.display = 'block';
        return;
    }
    
    const { servers } = statusData;
    let html = '<h3>üñ•Ô∏è Server Status</h3>';
    
    if (Object.keys(servers).length === 0) {
        html += '<p>No servers currently active.</p>';
    } else {
        // Collect unique place IDs first
        const uniquePlaceIds = new Set();
        const serversByPlaceId = new Map();
        
        for (const [jobId, serverInfo] of Object.entries(servers)) {
            if (serverInfo.placeId) {
                uniquePlaceIds.add(serverInfo.placeId);
                
                if (!serversByPlaceId.has(serverInfo.placeId)) {
                    serversByPlaceId.set(serverInfo.placeId, []);
                }
                serversByPlaceId.get(serverInfo.placeId).push({ jobId, serverInfo });
            }
        }
        
        console.log(`Found ${uniquePlaceIds.size} unique place IDs out of ${Object.keys(servers).length} servers`);
        
        // Sort servers alphabetically by jobId
        const sortedServers = Object.entries(servers).sort(([jobIdA], [jobIdB]) => jobIdA.localeCompare(jobIdB));
        
        for (const [jobId, serverInfo] of sortedServers) {
            const timeSinceLastPing = Date.now() - (serverInfo.lastPing || 0);
            const isOnline = timeSinceLastPing < 10000; // Consider offline if no ping in 30 seconds
            
            html += `<div class="server-item">
                <div class="server-header">
                    <span class="server-jobid">üñ•Ô∏è ${jobId}</span>
                    <span style="color: ${isOnline ? '#059669' : '#eab308'}; font-weight: 600;">
                        ${isOnline ? 'üü¢ Online' : 'üü° Not responding'}
                    </span>
                </div>
                <div class="server-place" id="place-${jobId}">
                    üéÆ Loading place info...
                </div>
                <div class="server-players">
                    üë• ${serverInfo.playerCount || 0} players: ${(serverInfo.players || []).join(', ') || 'None'}
                </div>
                <div style="font-size: 12px; color: #6b7280; margin-top: 8px;">
                    Last ping: ${serverInfo.lastSeen ? formatTime(new Date(serverInfo.lastSeen).getTime()) : 'Never'}
                </div>
            </div>`;
        }
        
        // Fetch place info for unique IDs only, with rate limiting
        const placeIds = Array.from(uniquePlaceIds);
        fetchPlaceInfoBatch(placeIds, serversByPlaceId);
    }
    
    serverStatusDiv.innerHTML = html;
    serverStatusDiv.style.display = 'block';
}
        
async function refreshStatus() {
    console.log('Refreshing status...');
    const statusData = await fetchExecutionStatus();
    if (statusData) {
        displayExecutionStatus(statusData);
        displayServerStatus(statusData);
        showStatus('‚úÖ Status refreshed successfully', 'success', 3000);
    } else {
        showStatus('‚ùå Failed to refresh status', 'error');
    }
}

// Improved status checking function
function checkMessageStatus(message, allStatusData) {
    // If message exists in executedMessages, it's successful
    if (allStatusData && allStatusData.executedMessages) {
        const executedMessage = allStatusData.executedMessages.find(msg => msg.id === message.id);
        if (executedMessage) {
            return 'success';
        }
    }
    
    // If message has executedAt timestamp, it's successful
    if (message.executedAt) {
        return 'success';
    }
    
    // Otherwise, it's still pending
    return 'pending';
}

// Monitor execution status with improved logic
async function monitorExecution() {
    if (isMonitoring) {
        console.log('Already monitoring, skipping...');
        return;
    }
    
    isMonitoring = true;
    console.log('Starting execution monitoring...');
    
    const startTime = Date.now();
    const timeout = 60000; // 60 seconds timeout
    let consecutiveEmptyChecks = 0;
    let lastExecutedCount = 0;
    let stableChecks = 0;
    const maxStableChecks = 3;
    
    try {
        while (Date.now() - startTime < timeout) {
            const statusData = await fetchExecutionStatus();
            
            if (statusData === null) {
                console.log('Status data is null, retrying...');
                await new Promise(resolve => setTimeout(resolve, 2000));
                continue;
            }
            
            displayExecutionStatus(statusData);
            
            // executedMessages is at the top level of statusData
            const executedMessages = statusData.executedMessages || [];
            const executedCount = executedMessages.length;
            
            // users and jobids are inside the message object
            const messageData = statusData.message || {};
            
            // Count pending messages
            let pendingCount = 0;
            
            if (messageData.users) {
                for (const messages of Object.values(messageData.users)) {
                    if (Array.isArray(messages)) {
                        pendingCount += messages.length;
                    }
                }
            }
            
            if (messageData.jobids) {
                for (const messages of Object.values(messageData.jobids)) {
                    if (Array.isArray(messages)) {
                        pendingCount += messages.length;
                    }
                }
            }
            
            console.log(`Executed: ${executedCount}, Pending: ${pendingCount}`);
            
            // Check if we have messages to monitor
            const totalMessages = executedCount + pendingCount;
            
            if (totalMessages === 0) {
                consecutiveEmptyChecks++;
                if (consecutiveEmptyChecks >= 3) {
                    console.log('No messages found after multiple checks, stopping monitoring');
                    showStatus('‚ÑπÔ∏è No messages to monitor', 'info');
                    break;
                }
            } else {
                consecutiveEmptyChecks = 0;
                
                // Check if executed count is stable and no pending messages
                if (executedCount === lastExecutedCount && pendingCount === 0 && executedCount > 0) {
                    stableChecks++;
                } else {
                    stableChecks = 0;
                    lastExecutedCount = executedCount;
                }
                
                // If no pending messages and we have executed messages
                if (pendingCount === 0 && executedCount > 0 && stableChecks >= maxStableChecks) {
                    showStatus(`‚úÖ All ${executedCount} message(s) executed successfully!`, 'success');
                    break;
                }
                
                // If we have pending messages, show status
                if (pendingCount > 0) {
                    showStatus(`‚è≥ ${pendingCount} message(s) pending, ${executedCount} executed`, 'info', 2000);
                }
            }
            
            // Wait before next check
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        // Handle timeout
        if (Date.now() - startTime >= timeout) {
            showStatus('‚è∞ Monitoring timeout - some messages may still be processing', 'warning');
        }
        
    } finally {
        isMonitoring = false;
        console.log('Monitoring stopped');
    }
}

// Optional: Function to clear cache if needed
function clearPlaceInfoCache() {
    placeInfoCache.clear();
    console.log('Place info cache cleared');
}

// Optional: Function to get cache statistics
function getCacheStats() {
    return {
        size: placeInfoCache.size,
        ids: Array.from(placeInfoCache.keys())
    };
}
        
// Handle username form submission
document.getElementById('usernameForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const username = document.getElementById('username').value.trim();
    const dataString = document.getElementById('usernameData').value.trim();
    const sendBtn = document.getElementById('sendUsernameBtn');
    
    if (!username || !dataString) {
        showStatus('Please fill in all fields', 'error');
        return;
    }
    
    sendBtn.disabled = true;
    sendBtn.innerHTML = '<span class="loading"></span>Sending...';
    
    try {
        const requestData = {
            username: username,
            data: dataString,
            timestamp: new Date().toISOString()
        };
        
        console.log('Sending username request:', requestData);
        
        const response = await fetch(defaultServerUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'User-Agent': 'RobloxStudio/1.0',
                'Referer': 'https://www.roblox.com'
            },
            body: JSON.stringify(requestData),
            mode: 'cors'
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const responseData = await response.json();
        console.log('Username response:', responseData);
        
        if (responseData.success) {
            showStatus(`‚úÖ Data sent to username "${username}"! Monitoring execution...`, 'success');
            // Wait a bit before starting monitoring to let the server process
            setTimeout(() => monitorExecution(), 2000);
        } else {
            showStatus(`‚ùå Server error: ${responseData.error || 'Unknown error'}`, 'error');
        }
    } catch (error) {
        console.error('Username request error:', error);
        showStatus(`‚ùå Request failed: ${error.message}`, 'error');
    } finally {
        sendBtn.disabled = false;
        sendBtn.innerHTML = 'Send to Username';
    }
});

// Handle job ID form submission
document.getElementById('jobidForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const jobId = document.getElementById('jobid').value.trim();
    const dataString = document.getElementById('jobidData').value.trim();
    const sendBtn = document.getElementById('sendJobidBtn');
    
    if (!jobId || !dataString) {
        showStatus('Please fill in all fields', 'error');
        return;
    }
    
    sendBtn.disabled = true;
    sendBtn.innerHTML = '<span class="loading"></span>Sending...';
    
    try {
        const requestData = {
            jobId: jobId,
            data: dataString,
            timestamp: new Date().toISOString()
        };
        
        console.log('Sending job ID request:', requestData);
        
        const response = await fetch(defaultServerUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'User-Agent': 'RobloxStudio/1.0',
                'Referer': 'https://www.roblox.com'
            },
            body: JSON.stringify(requestData),
            mode: 'cors'
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const responseData = await response.json();
        console.log('Job ID response:', responseData);
        
        if (responseData.success) {
            showStatus(`‚úÖ Data sent to Job ID "${jobId}"! Monitoring execution...`, 'success');
            // Wait a bit before starting monitoring to let the server process
            setTimeout(() => monitorExecution(), 2000);
        } else {
            showStatus(`‚ùå Server error: ${responseData.error || 'Unknown error'}`, 'error');
        }
    } catch (error) {
        console.error('Job ID request error:', error);
        showStatus(`‚ùå Request failed: ${error.message}`, 'error');
    } finally {
        sendBtn.disabled = false;
        sendBtn.innerHTML = 'Send to Job ID';
    }
});
    </script>
</body>
</html>
